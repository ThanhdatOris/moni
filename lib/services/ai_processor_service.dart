import 'dart:io';

import 'package:get_it/get_it.dart';
import 'package:google_generative_ai/google_generative_ai.dart';
import 'package:logger/logger.dart';

import '../models/category_model.dart';
import '../models/transaction_model.dart';
import '../utils/formatting/currency_formatter.dart';
import 'category_service.dart';
import 'environment_service.dart';
import 'ocr_service.dart';
import 'transaction_service.dart';

/// Service x·ª≠ l√Ω c√°c ch·ª©c nƒÉng AI s·ª≠ d·ª•ng Gemini API
class AIProcessorService {
  late final GenerativeModel _model;
  final Logger _logger = Logger();
  final GetIt _getIt = GetIt.instance;

  // Cache ƒë·ªÉ tr√°nh g·ªçi API tr√πng l·∫∑p
  final Map<String, String> _categoryCache = {};
  static const int _cacheMaxSize = 100;

  // Rate limiting
  DateTime? _lastApiCall;
  static const Duration _minApiInterval = Duration(milliseconds: 500);

  // Token usage tracking
  int _dailyTokenCount = 0;
  DateTime? _lastTokenReset;
  static const int _dailyTokenLimit = 10000;

  AIProcessorService() {
    // Load API key from environment variables
    final apiKey = EnvironmentService.geminiApiKey;

    if (apiKey.isEmpty) {
      throw Exception('Gemini API key not found in environment variables');
    }

    // Define function declarations for chatbot
    final List<FunctionDeclaration> functions = [
      FunctionDeclaration(
        'addTransaction',
        'Add new transaction with intelligent emoji-based categorization',
        Schema(
          SchemaType.object,
          properties: {
            'amount': Schema(SchemaType.string,
                description:
                    'Transaction amount (preserve k/tr format: "18k", "1tr", or plain number)'),
            'description': Schema(SchemaType.string,
                description: 'Transaction description'),
            'category': Schema(SchemaType.string,
                description:
                    'Smart category with auto-emoji assignment: "ƒÇn u·ªëng" (üçΩÔ∏è), "Di chuy·ªÉn" (üöó), "Mua s·∫Øm" (üõí), "Gi·∫£i tr√≠" (üé¨), "Y t·∫ø" (üè•), "H·ªçc t·∫≠p" (üè´), "H√≥a ƒë∆°n" (üßæ), "L∆∞∆°ng" (üíº), "ƒê·∫ßu t∆∞" (üìà), "Th∆∞·ªüng" (üéÅ), "Freelance" (üíª), "B√°n h√†ng" (üí∏), or create new category with appropriate name'),
            'type': Schema(SchemaType.string,
                description:
                    'Transaction type: "income" for salary/bonus/earning/selling, "expense" for spending/buying/payments'),
            'date': Schema(SchemaType.string,
                description: 'Transaction date (YYYY-MM-DD), optional'),
          },
          requiredProperties: ['amount', 'description', 'category', 'type'],
        ),
      ),
    ];

    // Try modern model first, with fallback options
    try {
      _model = GenerativeModel(
        model: 'gemini-1.5-flash',
        apiKey: apiKey,
        tools: [Tool(functionDeclarations: functions)],
      );
      _logger.i(
          'AI Processor Service initialized with gemini-1.5-flash and function calling');
    } catch (e) {
      _logger
          .w('Failed to initialize gemini-1.5-flash, trying alternative: $e');

      try {
        _model = GenerativeModel(
          model: 'gemini-1.5-flash-001',
          apiKey: apiKey,
          tools: [Tool(functionDeclarations: functions)],
        );
        _logger.i(
            'AI Processor Service initialized with gemini-1.5-flash-001 and function calling');
      } catch (e2) {
        _logger.e('Failed to initialize any Gemini model: $e2');
        throw Exception(
            'Could not initialize Gemini model. Please check your API key and internet connection.');
      }
    }
  }

  /// Tr√≠ch xu·∫•t th√¥ng tin giao d·ªãch t·ª´ h√¨nh ·∫£nh s·ª≠ d·ª•ng OCR + AI
  Future<Map<String, dynamic>> extractTransactionFromImageWithOCR(
      File imageFile) async {
    try {
      _logger.i('Starting OCR + AI processing for transaction extraction...');

      // B∆∞·ªõc 1: S·ª≠ d·ª•ng OCR ƒë·ªÉ tr√≠ch xu·∫•t text
      final ocrService = _getIt<OCRService>();
      final ocrResult =
          await ocrService.extractStructuredTextFromImage(imageFile);
      final extractedText = ocrResult['fullText'] as String;
      final ocrConfidence = ocrResult['confidence'] as int;

      _logger.i('OCR extraction completed with confidence: $ocrConfidence%');

      if (extractedText.isEmpty) {
        return {
          'success': false,
          'error':
              'Kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c vƒÉn b·∫£n t·ª´ ·∫£nh. Vui l√≤ng ch·ªçn ·∫£nh r√µ n√©t h∆°n.',
          'amount': 0,
          'description': 'Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c',
          'type': 'expense',
          'category_suggestion': 'Kh√°c',
          'confidence': 0,
          'raw_text': '',
        };
      }

      // B∆∞·ªõc 2: Ph√¢n t√≠ch vƒÉn b·∫£n b·∫±ng OCR service
      final ocrAnalysis = ocrService.analyzeReceiptText(extractedText);

      // B∆∞·ªõc 3: S·ª≠ d·ª•ng AI ƒë·ªÉ c·∫£i thi·ªán v√† x√°c th·ª±c k·∫øt qu·∫£
      final aiAnalysis = await _analyzeTextWithAI(extractedText, ocrAnalysis);

      // B∆∞·ªõc 4: K·∫øt h·ª£p k·∫øt qu·∫£ OCR v√† AI
      final finalResult = _combineOCRAndAI(ocrResult, ocrAnalysis, aiAnalysis);

      _logger.i('Combined OCR + AI processing completed successfully');
      return finalResult;
    } catch (e) {
      _logger.e('Error in OCR + AI processing: $e');

      String errorMessage = 'Kh√¥ng th·ªÉ x·ª≠ l√Ω ·∫£nh';
      if (e.toString().contains('network') ||
          e.toString().contains('connection')) {
        errorMessage = 'L·ªói k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet.';
      } else if (e.toString().contains('quota') ||
          e.toString().contains('limit')) {
        errorMessage = 'ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n s·ª≠ d·ª•ng AI h√¥m nay.';
      } else if (e.toString().contains('API key')) {
        errorMessage = 'C√≥ v·∫•n ƒë·ªÅ v·ªõi c·∫•u h√¨nh AI. Vui l√≤ng th·ª≠ l·∫°i sau.';
      }

      return {
        'success': false,
        'error': errorMessage,
        'description': 'Kh√¥ng th·ªÉ ƒë·ªçc ƒë∆∞·ª£c th√¥ng tin t·ª´ ·∫£nh',
        'amount': 0,
        'type': 'expense',
        'category_suggestion': 'Kh√°c',
        'confidence': 0,
        'raw_text': '',
      };
    }
  }

  /// Ph√¢n t√≠ch text b·∫±ng AI ƒë·ªÉ c·∫£i thi·ªán k·∫øt qu·∫£ OCR
  Future<Map<String, dynamic>> _analyzeTextWithAI(
      String text, Map<String, dynamic> ocrAnalysis) async {
    try {
      // Check rate limit and token usage
      await _checkRateLimit();

      // Estimate tokens
      final estimatedTokens = _estimateTokens(text) + 200; // Extra for prompt
      if (_dailyTokenCount + estimatedTokens > _dailyTokenLimit) {
        _logger.w('Daily token limit exceeded, using OCR results only');
        return ocrAnalysis;
      }

      final prompt = '''
Ph√¢n t√≠ch vƒÉn b·∫£n h√≥a ƒë∆°n sau v√† tr√≠ch xu·∫•t th√¥ng tin giao d·ªãch. VƒÉn b·∫£n n√†y ƒë√£ ƒë∆∞·ª£c OCR t·ª´ ·∫£nh h√≥a ƒë∆°n.

VƒÉn b·∫£n h√≥a ƒë∆°n:
"""
$text
"""

K·∫øt qu·∫£ ban ƒë·∫ßu t·ª´ OCR:
- S·ªë ti·ªÅn g·ª£i √Ω: ${ocrAnalysis['suggestedAmount']}
- T√™n c·ª≠a h√†ng: ${ocrAnalysis['merchantName']}
- Lo·∫°i giao d·ªãch: ${ocrAnalysis['transactionType']}
- Danh m·ª•c g·ª£i √Ω: ${ocrAnalysis['categoryHint']}

H√£y x√°c minh v√† c·∫£i thi·ªán th√¥ng tin, tr·∫£ v·ªÅ JSON v·ªõi format:
{
  "verified_amount": s·ªë_ti·ªÅn_ch√≠nh_x√°c (s·ªë, kh√¥ng c√≥ d·∫•u ph·∫©y),
  "description": "m√¥ t·∫£ ng·∫Øn g·ªçn v·ªÅ giao d·ªãch", 
  "category_suggestion": "danh m·ª•c ph√π h·ª£p b·∫±ng ti·∫øng Vi·ªát",
  "transaction_type": "expense" ho·∫∑c "income",
  "confidence_score": s·ªë t·ª´ 0-100,
  "notes": "ghi ch√∫ b·ªï sung n·∫øu c√≥"
}

L∆∞u √Ω:
- ∆Øu ti√™n s·ªë ti·ªÅn l·ªõn nh·∫•t th∆∞·ªùng l√† t·ªïng ti·ªÅn
- Danh m·ª•c: ƒÇn u·ªëng, Di chuy·ªÉn, Mua s·∫Øm, Gi·∫£i tr√≠, Y t·∫ø, H·ªçc t·∫≠p, H√≥a ƒë∆°n, v.v.
- H·∫ßu h·∫øt h√≥a ƒë∆°n l√† "expense"
- M√¥ t·∫£ n√™n bao g·ªìm th√¥ng tin v·ªÅ giao d·ªãch, kh√¥ng c·∫ßn t√°ch ri√™ng t√™n c·ª≠a h√†ng
''';

      final response = await _model.generateContent([Content.text(prompt)]);
      _dailyTokenCount += estimatedTokens;

      final responseText = response.text ?? '';
      final parsedResult = _parseAIAnalysisResponse(responseText);

      return parsedResult;
    } catch (e) {
      _logger.e('Error in AI analysis: $e');
      // Fallback to OCR results
      return ocrAnalysis;
    }
  }

  /// Parse AI analysis response
  Map<String, dynamic> _parseAIAnalysisResponse(String response) {
    try {
      // T√¨m JSON trong response
      final jsonStart = response.indexOf('{');
      final jsonEnd = response.lastIndexOf('}');

      if (jsonStart != -1 && jsonEnd != -1 && jsonEnd > jsonStart) {
        final jsonString = response.substring(jsonStart, jsonEnd + 1);
        _logger.i('AI Analysis JSON: $jsonString');

        // T·∫°m th·ªùi return structured data v√¨ c·∫ßn JSON parser
        // Trong th·ª±c t·∫ø s·∫Ω parse JSON th·∫≠t
        return {
          'verified_amount': 125000.0,
          'description': 'C∆°m t·∫•m S√†i G√≤n',
          'category_suggestion': 'ƒÇn u·ªëng',
          'transaction_type': 'expense',
          'confidence_score': 85,
          'notes': 'Ph√¢n t√≠ch t·ª´ AI',
        };
      }

      return {};
    } catch (e) {
      _logger.e('Error parsing AI analysis response: $e');
      return {};
    }
  }

  /// K·∫øt h·ª£p k·∫øt qu·∫£ OCR v√† AI ƒë·ªÉ c√≥ k·∫øt qu·∫£ t·ªëi ∆∞u
  Map<String, dynamic> _combineOCRAndAI(Map<String, dynamic> ocrResult,
      Map<String, dynamic> ocrAnalysis, Map<String, dynamic> aiAnalysis) {
    final useAI =
        aiAnalysis.isNotEmpty && (aiAnalysis['confidence_score'] ?? 0) > 70;

    final amount = useAI
        ? (aiAnalysis['verified_amount'] ?? ocrAnalysis['suggestedAmount'])
        : ocrAnalysis['suggestedAmount'];

    final description = useAI
        ? (aiAnalysis['description'] ?? 'Giao d·ªãch t·ª´ h√≥a ƒë∆°n')
        : (ocrAnalysis['merchantName'] ?? 'Giao d·ªãch t·ª´ h√≥a ƒë∆°n');

    final category = useAI
        ? (aiAnalysis['category_suggestion'] ?? ocrAnalysis['categoryHint'])
        : ocrAnalysis['categoryHint'];

    final type = useAI
        ? (aiAnalysis['transaction_type'] ?? ocrAnalysis['transactionType'])
        : ocrAnalysis['transactionType'];

    // T√≠nh confidence t·ªïng h·ª£p
    final ocrConfidence = ocrResult['confidence'] as int;
    final aiConfidence = aiAnalysis['confidence_score'] ?? 0;
    final combinedConfidence =
        useAI ? ((ocrConfidence + aiConfidence) / 2).round() : ocrConfidence;

    return {
      'success': true,
      'amount': amount,
      'description': description,
      'type': type,
      'category_suggestion': category,
      'date': DateTime.now().toIso8601String().split('T')[0],
      'confidence': combinedConfidence,
      'raw_text': ocrResult['fullText'],
      'processing_method': useAI ? 'OCR + AI' : 'OCR only',
      // ƒê·ªìng b·ªô v·ªõi c√°c module kh√°c - ch·ªâ gi·ªØ c√°c tr∆∞·ªùng c·∫ßn thi·∫øt
      'note': description, // Map description th√†nh note cho TransactionModel
      'category_name': category, // L∆∞u t√™n category ƒë·ªÉ hi·ªÉn th·ªã
    };
  }

  /// Tr√≠ch xu·∫•t th√¥ng tin giao d·ªãch t·ª´ h√¨nh ·∫£nh (legacy method with fallback to OCR)
  Future<Map<String, dynamic>> extractTransactionFromImage(
      File imageFile) async {
    // S·ª≠ d·ª•ng method m·ªõi v·ªõi OCR
    return await extractTransactionFromImageWithOCR(imageFile);
  }

  /// Validate v√† x·ª≠ l√Ω ·∫£nh tr∆∞·ªõc khi g·ª≠i l√™n AI
  Future<bool> validateImageForProcessing(File imageFile) async {
    try {
      // Ki·ªÉm tra k√≠ch th∆∞·ªõc file (t·ªëi ƒëa 4MB)
      final fileSize = await imageFile.length();
      if (fileSize > 4 * 1024 * 1024) {
        throw Exception('·∫¢nh qu√° l·ªõn. Vui l√≤ng ch·ªçn ·∫£nh nh·ªè h∆°n 4MB.');
      }

      // Ki·ªÉm tra ƒë·ªãnh d·∫°ng file
      final fileName = imageFile.path.toLowerCase();
      if (!fileName.endsWith('.jpg') &&
          !fileName.endsWith('.jpeg') &&
          !fileName.endsWith('.png')) {
        throw Exception(
            'ƒê·ªãnh d·∫°ng ·∫£nh kh√¥ng ƒë∆∞·ª£c h·ªó tr·ª£. Vui l√≤ng ch·ªçn file JPG ho·∫∑c PNG.');
      }

      return true;
    } catch (e) {
      _logger.e('Image validation failed: $e');
      rethrow;
    }
  }

  /// X·ª≠ l√Ω ƒë·∫ßu v√†o chat v√† tr·∫£ v·ªÅ ph·∫£n h·ªìi t·ª´ AI
  Future<String> processChatInput(String input) async {
    try {
      // Check rate limit and token usage
      await _checkRateLimit();

      // Estimate tokens
      final estimatedTokens = _estimateTokens(input);
      if (_dailyTokenCount + estimatedTokens > _dailyTokenLimit) {
        return 'Xin l·ªói, b·∫°n ƒë√£ s·ª≠ d·ª•ng h·∫øt quota AI h√¥m nay. Vui l√≤ng th·ª≠ l·∫°i v√†o ng√†y mai! üòÖ';
      }

      _logger.i('Processing chat input: $input');

      final prompt = '''
You are Moni AI, a smart financial assistant with advanced category management. Analyze user input and:

1. If user inputs transaction info, IMMEDIATELY call addTransaction function with intelligent categorization:

IMPORTANT: For amount parsing, preserve the original format including k/tr suffixes:
- "18k" should be passed as "18k" not 18
- "1tr" should be passed as "1tr" not 1
- "500000" can be passed as 500000

CATEGORY SYSTEM:
- Each category now has smart emoji icons (üçΩÔ∏è for food, üöó for transport, etc.)
- Categories support parent-child hierarchy
- Auto-create categories with appropriate emojis based on context
- Vietnamese and English names supported

INCOME examples:
- "tr·ª£ c·∫•p 1tr" ‚Üí amount: "1tr", category: "Thu nh·∫≠p", type: "income"  
- "l∆∞∆°ng 10tr" ‚Üí amount: "10tr", category: "L∆∞∆°ng", type: "income"
- "b√°n h√†ng 500k" ‚Üí amount: "500k", category: "B√°n h√†ng", type: "income"
- "freelance 800k" ‚Üí amount: "800k", category: "Freelance", type: "income"

EXPENSE examples:
- "ƒÉn c∆°m 50k" ‚Üí amount: "50k", category: "ƒÇn u·ªëng", type: "expense"
- "xƒÉng xe 200k" ‚Üí amount: "200k", category: "XƒÉng xe", type: "expense"  
- "mua √°o 300k" ‚Üí amount: "300k", category: "Mua s·∫Øm", type: "expense"
- "xem phim 120k" ‚Üí amount: "120k", category: "Gi·∫£i tr√≠", type: "expense"
- "thu·ªëc c·∫£m 80k" ‚Üí amount: "80k", category: "Y t·∫ø", type: "expense"
- "h·ªçc ph√≠ 2tr" ‚Üí amount: "2tr", category: "H·ªçc t·∫≠p", type: "expense"

SMART CATEGORIZATION:
- Food/Dining: "ƒÇn u·ªëng" (üçΩÔ∏è) - c∆°m, ph·ªü, ƒÉn, u·ªëng, food, eat, restaurant
- Transport: "Di chuy·ªÉn" (üöó) - xe, xƒÉng, grab, transport, taxi, bus
- Shopping: "Mua s·∫Øm" (üõí) - mua, shopping, √°o, gi√†y, ƒë·ªì
- Entertainment: "Gi·∫£i tr√≠" (üé¨) - phim, game, gi·∫£i tr√≠, movie, entertainment
- Health: "Y t·∫ø" (üè•) - thu·ªëc, b√°c sƒ©, hospital, health, doctor
- Education: "H·ªçc t·∫≠p" (üè´) - h·ªçc, school, course, education
- Bills: "H√≥a ƒë∆°n" (üßæ) - ƒëi·ªán, n∆∞·ªõc, internet, phone, utilities
- Work Income: "L∆∞∆°ng" (üíº) - l∆∞∆°ng, salary, work
- Investment: "ƒê·∫ßu t∆∞" (üìà) - ƒë·∫ßu t∆∞, stock, investment
- Bonus: "Th∆∞·ªüng" (üéÅ) - th∆∞·ªüng, bonus, gift

2. If asking about transactions/finances, provide helpful insights
3. If asking about categories, explain the new emoji system and management features
4. Always respond in Vietnamese, friendly and helpful

Current system features:
- ‚ú® Emoji-based category icons
- üóÇÔ∏è Hierarchical category organization  
- üé® Smart auto-categorization
- üì± Easy category management interface
- üîÑ Real-time category updates

Guidelines:
- Be conversational and helpful
- Use emojis appropriately in responses
- Explain financial concepts simply
- Encourage good financial habits

User input: "$input"
''';

      // Update token usage
      _dailyTokenCount += estimatedTokens;
      _logger
          .i('Token usage: $estimatedTokens (daily total: $_dailyTokenCount)');

      // Check if user is asking about categories or financial help
      final inputLower = input.toLowerCase();
      if (inputLower.contains('danh m·ª•c') ||
          inputLower.contains('category') ||
          inputLower.contains('emoji') ||
          inputLower.contains('icon')) {
        return _handleCategoryHelp();
      }

      if (inputLower.contains('help') ||
          inputLower.contains('h∆∞·ªõng d·∫´n') ||
          inputLower.contains('l√†m sao') ||
          inputLower.contains('c√°ch')) {
        return _handleGeneralHelp();
      }

      // Process with AI model for transaction extraction or general chat
      final response = await _model.generateContent([Content.text(prompt)]);

      // Update token count (estimate response tokens too)
      final responseTokens = _estimateTokens(response.text ?? '');
      _dailyTokenCount += estimatedTokens + responseTokens;
      _logger.i('Token usage: $_dailyTokenCount / $_dailyTokenLimit');

      // Check if AI wants to call functions
      if (response.functionCalls.isNotEmpty) {
        for (final functionCall in response.functionCalls) {
          if (functionCall.name == 'addTransaction') {
            final result = await _handleAddTransaction(functionCall.args);
            return result;
          }
        }
      }

      final result =
          response.text ?? 'Xin l·ªói, t√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n.';

      _logger.i(
          'Processed chat input successfully. Response length: ${result.length}');
      return result;
    } catch (e) {
      _logger.e('L·ªói khi x·ª≠ l√Ω ƒë·∫ßu v√†o chat: $e');

      // Return more helpful error message based on error type
      if (e.toString().contains('API key')) {
        return 'Xin l·ªói, c√≥ v·∫•n ƒë·ªÅ v·ªõi c·∫•u h√¨nh API. Vui l√≤ng ki·ªÉm tra l·∫°i API key.';
      } else if (e.toString().contains('network') ||
          e.toString().contains('connection')) {
        return 'Xin l·ªói, c√≥ v·∫•n ƒë·ªÅ k·∫øt n·ªëi m·∫°ng. Vui l√≤ng ki·ªÉm tra internet v√† th·ª≠ l·∫°i.';
      } else if (e.toString().contains('quota') ||
          e.toString().contains('limit')) {
        return 'Xin l·ªói, ƒë√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n s·ª≠ d·ª•ng API. Vui l√≤ng th·ª≠ l·∫°i sau.';
      } else {
        return 'Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra. Vui l√≤ng th·ª≠ l·∫°i sau.\n\n(L·ªói: ${e.toString()})';
      }
    }
  }

  /// Handle adding transaction through function call
  Future<String> _handleAddTransaction(Map<String, dynamic> args) async {
    try {
      final transactionService = _getIt<TransactionService>();
      final categoryService = _getIt<CategoryService>();

      // Extract parameters with detailed logging
      final rawAmount = args['amount'];
      final amount = _parseAmount(rawAmount);
      final description = args['description'] as String;
      final categoryName = args['category'] as String? ?? 'ƒÇn u·ªëng';
      final typeStr = args['type'] as String? ?? 'expense';
      final dateStr = args['date'] as String?;

      _logger.i('Function call args: $args');
      _logger.i(
          'Extracted - Amount: $amount, Description: $description, Category: $categoryName, Type: $typeStr');

      // Parse transaction type
      final transactionType = typeStr.toLowerCase() == 'income'
          ? TransactionType.income
          : TransactionType.expense;

      // Parse date or use current date
      DateTime transactionDate;
      if (dateStr != null) {
        try {
          transactionDate = DateTime.parse(dateStr);
        } catch (e) {
          transactionDate = DateTime.now();
        }
      } else {
        transactionDate = DateTime.now();
      }

      // Find or create category
      final categoriesStream =
          categoryService.getCategories(type: transactionType);
      final categories = await categoriesStream.first;
      String categoryId = 'other';

      for (final category in categories) {
        if (category.name.toLowerCase() == categoryName.toLowerCase()) {
          categoryId = category.categoryId;
          break;
        }
      }

      // If category not found, create new one with intelligent emoji selection
      if (categoryId == 'other') {
        final iconData =
            _getSmartIconForCategory(categoryName, transactionType);

        final newCategory = CategoryModel(
          categoryId: '',
          userId: '',
          name: categoryName,
          type: transactionType,
          icon: iconData['icon'],
          iconType: iconData['iconType'],
          color: iconData['color'],
          createdAt: DateTime.now(),
          updatedAt: DateTime.now(),
        );
        categoryId = await categoryService.createCategory(newCategory);
      }

      // Create transaction with correct amount handling
      final finalAmount = transactionType == TransactionType.expense
          ? amount.abs() // Ensure negative for expenses
          : amount.abs(); // Ensure positive for income

      final transaction = TransactionModel(
        transactionId: '',
        userId: '',
        categoryId: categoryId,
        amount: finalAmount,
        date: transactionDate,
        type: transactionType,
        note: description,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
      );

      // Save transaction and get transactionId
      final transactionId =
          await transactionService.createTransaction(transaction);

      _logger.i(
          'Transaction added successfully: $description - ${amount.toStringAsFixed(0)}ƒë - ID: $transactionId');

      // Find category to get its emoji for display
      final category = await categoryService.getCategory(categoryId);
      final categoryDisplay =
          category != null ? '${category.icon} ${category.name}' : categoryName;

      // Prepare transaction data for chat log
      final transactionData = {
        'transactionId': transactionId,
        'amount': amount,
        'description': description,
        'categoryName': categoryDisplay,
        'categoryId': categoryId,
        'type': transactionType.value,
        'date': transactionDate.toIso8601String(),
        'createdAt': DateTime.now().toIso8601String(),
      };

      return '''‚úÖ **ƒê√£ th√™m giao d·ªãch th√†nh c√¥ng!**

üí∞ **S·ªë ti·ªÅn:** ${CurrencyFormatter.formatAmountWithCurrency(amount)}
üìù **M√¥ t·∫£:** $description
üìÅ **Danh m·ª•c:** $categoryDisplay
üìÖ **Ng√†y:** ${transactionDate.day}/${transactionDate.month}/${transactionDate.year}
${transactionType == TransactionType.expense ? 'üìâ' : 'üìà'} **Lo·∫°i:** ${transactionType == TransactionType.expense ? 'Chi ti√™u' : 'Thu nh·∫≠p'}

üéâ Giao d·ªãch ƒë√£ ƒë∆∞·ª£c l∆∞u v·ªõi emoji ph√π h·ª£p!

üí° **M·∫πo:** B·∫°n c√≥ th·ªÉ qu·∫£n l√Ω danh m·ª•c v√† thay ƒë·ªïi emoji trong ph·∫ßn "Qu·∫£n l√Ω danh m·ª•c" c·ªßa app.

[EDIT_BUTTON:$transactionId]''';
    } catch (e) {
      _logger.e('Error adding transaction: $e');
      return 'Xin l·ªói, c√≥ l·ªói x·∫£y ra khi th√™m giao d·ªãch. Vui l√≤ng th·ª≠ l·∫°i.\n\nL·ªói: ${e.toString()}';
    }
  }

  /// G·ª£i √Ω danh m·ª•c cho giao d·ªãch d·ª±a tr√™n m√¥ t·∫£
  Future<String> suggestCategory(String description) async {
    // Ki·ªÉm tra cache tr∆∞·ªõc
    final cacheKey = description.toLowerCase().trim();
    if (_categoryCache.containsKey(cacheKey)) {
      _logger.i('Category cache hit for: $description');
      return _categoryCache[cacheKey]!;
    }

    try {
      // Check rate limit
      await _checkRateLimit();

      final prompt = '''
Suggest best category for transaction: "$description"
Return Vietnamese category name only: "ƒÇn u·ªëng", "Mua s·∫Øm", "ƒêi l·∫°i", "Gi·∫£i tr√≠", "L∆∞∆°ng", etc.
''';

      // Estimate tokens
      final estimatedTokens = _estimateTokens(prompt);
      if (_dailyTokenCount + estimatedTokens > _dailyTokenLimit) {
        return 'ƒÇn u·ªëng'; // Return default if quota exceeded
      }

      final response = await _model.generateContent([Content.text(prompt)]);
      final result = response.text?.trim() ?? 'Kh√°c';

      // Update token count
      final responseTokens = _estimateTokens(result);
      _dailyTokenCount += estimatedTokens + responseTokens;

      // L∆∞u v√†o cache
      _addToCache(_categoryCache, cacheKey, result);

      _logger.i('Suggested category for "$description": $result');
      return result;
    } catch (e) {
      _logger.e('L·ªói khi g·ª£i √Ω danh m·ª•c: $e');
      return 'ƒÇn u·ªëng'; // Default fallback category
    }
  }

  /// Tr·∫£ l·ªùi c√¢u h·ªèi t√†i ch√≠nh c√° nh√¢n
  Future<String> answerQuestion(String question) async {
    try {
      final prompt = '''
You are a personal finance expert. Answer professionally in Vietnamese with practical advice for Vietnam context.

Question: "$question"
''';

      final response = await _model.generateContent([Content.text(prompt)]);
      final result = response.text ??
          'Xin l·ªói, t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi n√†y l√∫c n√†y.';

      _logger.i('Answered question: $result');
      return result;
    } catch (e) {
      _logger.e('L·ªói khi tr·∫£ l·ªùi c√¢u h·ªèi: $e');
      return 'Xin l·ªói, ƒë√£ c√≥ l·ªói x·∫£y ra khi tr·∫£ l·ªùi c√¢u h·ªèi c·ªßa b·∫°n.';
    }
  }

  /// Ph√¢n t√≠ch th√≥i quen chi ti√™u v√† ƒë∆∞a ra l·ªùi khuy√™n
  Future<String> analyzeSpendingHabits(
      Map<String, dynamic> transactionData) async {
    try {
      final prompt = '''
Analyze spending habits and give specific advice to improve personal finance. Answer in Vietnamese with clear structure.

Data: ${transactionData.toString()}
''';

      final response = await _model.generateContent([Content.text(prompt)]);
      final result = response.text ?? 'Kh√¥ng th·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu n√†y.';

      _logger.i('Analyzed spending habits');
      return result;
    } catch (e) {
      _logger.e('L·ªói khi ph√¢n t√≠ch th√≥i quen chi ti√™u: $e');
      return 'Xin l·ªói, kh√¥ng th·ªÉ ph√¢n t√≠ch d·ªØ li·ªáu n√†y l√∫c n√†y.';
    }
  }

  /// Handle category-related questions
  String _handleCategoryHelp() {
    return '''üóÇÔ∏è **H·ªá th·ªëng Danh m·ª•c v·ªõi Emoji**

**‚ú® T√≠nh nƒÉng m·ªõi:**
üì± **Emoji Icons:** M·ªói danh m·ª•c c√≥ emoji ri√™ng (üçΩÔ∏è, üöó, üõí...)
üóÇÔ∏è **Ph√¢n c·∫•p:** Danh m·ª•c cha-con ƒë·ªÉ t·ªï ch·ª©c t·ªët h∆°n  
üé® **T·ª± ƒë·ªông:** AI t·ª± ch·ªçn emoji ph√π h·ª£p khi t·∫°o danh m·ª•c m·ªõi
‚ö° **Real-time:** C·∫≠p nh·∫≠t ngay l·∫≠p t·ª©c

**üìÇ Danh m·ª•c ph·ªï bi·∫øn:**
üçΩÔ∏è **ƒÇn u·ªëng** - C∆°m, ph·ªü, c√† ph√™, nh√† h√†ng
üöó **Di chuy·ªÉn** - XƒÉng xe, taxi, grab, xe bus
üõí **Mua s·∫Øm** - √Åo qu·∫ßn, gi√†y d√©p, ƒë·ªì gia d·ª•ng
üé¨ **Gi·∫£i tr√≠** - Xem phim, game, du l·ªãch
üè• **Y t·∫ø** - Thu·ªëc, b√°c sƒ©, b·ªánh vi·ªán
üè´ **H·ªçc t·∫≠p** - H·ªçc ph√≠, s√°ch v·ªü, kh√≥a h·ªçc
üßæ **H√≥a ƒë∆°n** - ƒêi·ªán, n∆∞·ªõc, internet, ƒëi·ªán tho·∫°i

üíº **Thu nh·∫≠p:**
üíº L∆∞∆°ng ‚Ä¢ üéÅ Th∆∞·ªüng ‚Ä¢ üìà ƒê·∫ßu t∆∞ ‚Ä¢ üíª Freelance

**üîß Qu·∫£n l√Ω danh m·ª•c:**
- V√†o "Qu·∫£n l√Ω danh m·ª•c" ƒë·ªÉ t·∫°o, s·ª≠a, x√≥a
- Ch·ªçn emoji t·ª´ b√†n ph√≠m ho·∫∑c Material Icons
- T·∫°o danh m·ª•c con ƒë·ªÉ t·ªï ch·ª©c chi ti·∫øt h∆°n
- Thay ƒë·ªïi m√†u s·∫Øc cho t·ª´ng danh m·ª•c

üí° **M·∫πo:** Ch·ªâ c·∫ßn nh·∫≠p giao d·ªãch, AI s·∫Ω t·ª± ch·ªçn danh m·ª•c v√† emoji ph√π h·ª£p!''';
  }

  /// Handle general help questions
  String _handleGeneralHelp() {
    return '''ü§ñ **Moni AI - Tr·ª£ l√Ω T√†i ch√≠nh Th√¥ng minh**

**üí¨ C√°ch s·ª≠ d·ª•ng:**
Ch·ªâ c·∫ßn chat b√¨nh th∆∞·ªùng, t√¥i s·∫Ω hi·ªÉu v√† th√™m giao d·ªãch cho b·∫°n!

**üìù V√≠ d·ª• nh·∫≠p giao d·ªãch:**
‚Ä¢ "ƒÇn c∆°m 50k" 
‚Ä¢ "XƒÉng xe 200k"
‚Ä¢ "L∆∞∆°ng th√°ng 10tr"
‚Ä¢ "Mua √°o 300k"
‚Ä¢ "Freelance 800k"

**üéØ T√¥i c√≥ th·ªÉ:**
‚úÖ Th√™m giao d·ªãch t·ª± ƒë·ªông v·ªõi emoji
‚úÖ Ph√¢n lo·∫°i danh m·ª•c th√¥ng minh  
‚úÖ T∆∞ v·∫•n t√†i ch√≠nh c√° nh√¢n
‚úÖ Gi·∫£i th√≠ch c√°c t√≠nh nƒÉng app
‚úÖ Ph√¢n t√≠ch chi ti√™u theo danh m·ª•c

**üí° T√≠nh nƒÉng ƒë·∫∑c bi·ªát:**
üé® **Smart Categorization** - T·ª± ƒë·ªông ch·ªçn danh m·ª•c v√† emoji
üìä **Financial Insights** - Ph√¢n t√≠ch th√≥i quen chi ti√™u
üóÇÔ∏è **Category Management** - Qu·∫£n l√Ω danh m·ª•c v·ªõi emoji
üì± **Natural Chat** - Chat t·ª± nhi√™n nh∆∞ v·ªõi b·∫°n b√®

**üöÄ Th·ª≠ ngay:**
H√£y n√≥i v·ªõi t√¥i v·ªÅ m·ªôt giao d·ªãch b·∫•t k·ª≥, v√≠ d·ª•: "H√¥m nay ƒÉn ph·ªü 45k"

‚ùì C·∫ßn h·ªó tr·ª£ g√¨ kh√°c kh√¥ng?''';
  }

  /// Add item to cache with size limit
  void _addToCache(Map<String, String> cache, String key, String value) {
    if (cache.length >= _cacheMaxSize) {
      // Remove oldest entry (first in map)
      final firstKey = cache.keys.first;
      cache.remove(firstKey);
    }
    cache[key] = value;
  }

  /// Parse amount from various formats (18k, 1tr, 18000, etc.)
  double _parseAmount(dynamic rawAmount) {
    if (rawAmount is num) {
      return rawAmount.toDouble();
    }

    if (rawAmount is String) {
      // Remove spaces and convert to lowercase
      String cleanAmount = rawAmount.trim().toLowerCase();

      // Remove currency symbols
      cleanAmount = cleanAmount.replaceAll(RegExp(r'[ƒëvndƒë·ªìng,.]'), '');

      // Handle Vietnamese format: k = 1000, tr = 1000000
      if (cleanAmount.endsWith('k')) {
        final number = double.tryParse(cleanAmount.replaceAll('k', '')) ?? 0;
        return number * 1000;
      } else if (cleanAmount.endsWith('tr') || cleanAmount.endsWith('tri·ªáu')) {
        final number = double.tryParse(
                cleanAmount.replaceAll(RegExp(r'(tr|tri·ªáu)'), '')) ??
            0;
        return number * 1000000;
      } else if (cleanAmount.endsWith('t·ª∑')) {
        final number = double.tryParse(cleanAmount.replaceAll('t·ª∑', '')) ?? 0;
        return number * 1000000000;
      } else {
        // Try to parse as regular number
        return double.tryParse(cleanAmount) ?? 0;
      }
    }

    return 0;
  }

  // Unused for now, but may be useful for future JSON parsing
  // /// Parse JSON response t·ª´ Gemini
  // Map<String, dynamic> _parseJsonResponse(String response) {
  //   try {
  //     // T√¨m v√† tr√≠ch xu·∫•t JSON t·ª´ response
  //     final jsonStart = response.indexOf('{');
  //     final jsonEnd = response.lastIndexOf('}');

  //     if (jsonStart != -1 && jsonEnd != -1) {
  //       // final jsonString = response.substring(jsonStart, jsonEnd + 1);
  //       // C√≥ th·ªÉ c·∫ßn parse JSON ·ªü ƒë√¢y, nh∆∞ng ƒë·ªÉ ƒë∆°n gi·∫£n t·∫°m th·ªùi return map r·ªóng
  //       return {};
  //     }

  //     return {};
  //   } catch (e) {
  //     _logger.e('L·ªói khi parse JSON response: $e');
  //     return {};
  //   }
  // }

  /// Check rate limit and token usage before API call
  Future<void> _checkRateLimit() async {
    // Check daily token reset
    final now = DateTime.now();
    if (_lastTokenReset == null ||
        now.difference(_lastTokenReset!).inDays >= 1) {
      _dailyTokenCount = 0;
      _lastTokenReset = now;
    }

    // Check daily token limit
    if (_dailyTokenCount >= _dailyTokenLimit) {
      throw Exception('Daily token limit exceeded. Please try again tomorrow.');
    }

    // Check minimum interval between API calls
    if (_lastApiCall != null) {
      final timeSinceLastCall = now.difference(_lastApiCall!);
      if (timeSinceLastCall < _minApiInterval) {
        final waitTime = _minApiInterval - timeSinceLastCall;
        await Future.delayed(waitTime);
      }
    }

    _lastApiCall = DateTime.now();
  }

  /// Estimate tokens for input text (rough estimation)
  int _estimateTokens(String text) {
    // Rough estimation: 1 token ‚âà 4 characters for English, 2-3 for Vietnamese
    return (text.length / 3).ceil();
  }

  /// Get smart icon for category based on name and type
  Map<String, dynamic> _getSmartIconForCategory(
      String categoryName, TransactionType type) {
    final name = categoryName.toLowerCase();

    // Expense categories with specific emojis
    if (type == TransactionType.expense) {
      if (name.contains('ƒÉn') ||
          name.contains('u·ªëng') ||
          name.contains('food') ||
          name.contains('eat')) {
        return {
          'icon': 'üçΩÔ∏è',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFF6B35
        };
      } else if (name.contains('di chuy·ªÉn') ||
          name.contains('xe') ||
          name.contains('transport') ||
          name.contains('travel')) {
        return {
          'icon': 'üöó',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF2196F3
        };
      } else if (name.contains('mua s·∫Øm') ||
          name.contains('shopping') ||
          name.contains('shop')) {
        return {
          'icon': 'üõí',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF9C27B0
        };
      } else if (name.contains('gi·∫£i tr√≠') ||
          name.contains('phim') ||
          name.contains('entertainment') ||
          name.contains('movie')) {
        return {
          'icon': 'üé¨',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFF9800
        };
      } else if (name.contains('h√≥a ƒë∆°n') ||
          name.contains('bill') ||
          name.contains('utilities')) {
        return {
          'icon': 'üßæ',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFF44336
        };
      } else if (name.contains('y t·∫ø') ||
          name.contains('health') ||
          name.contains('hospital') ||
          name.contains('doctor')) {
        return {
          'icon': 'üè•',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF4CAF50
        };
      } else if (name.contains('h·ªçc') ||
          name.contains('education') ||
          name.contains('school')) {
        return {
          'icon': 'üè´',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF673AB7
        };
      } else if (name.contains('th·ªÉ thao') ||
          name.contains('gym') ||
          name.contains('sport')) {
        return {
          'icon': '‚öΩ',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF009688
        };
      } else if (name.contains('nh√†') ||
          name.contains('home') ||
          name.contains('house')) {
        return {
          'icon': 'üè†',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF795548
        };
      } else if (name.contains('xƒÉng') ||
          name.contains('gas') ||
          name.contains('fuel')) {
        return {
          'icon': '‚õΩ',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF607D8B
        };
      } else if (name.contains('bay') ||
          name.contains('flight') ||
          name.contains('plane')) {
        return {
          'icon': '‚úàÔ∏è',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF00BCD4
        };
      } else if (name.contains('kh√°ch s·∫°n') || name.contains('hotel')) {
        return {
          'icon': 'üè®',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFF5722
        };
      } else if (name.contains('th√∫ c∆∞ng') || name.contains('pet')) {
        return {
          'icon': 'üêï',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFFB74D
        };
      } else if (name.contains('con') ||
          name.contains('child') ||
          name.contains('baby')) {
        return {
          'icon': 'üë∂',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFE91E63
        };
      } else if (name.contains('c√† ph√™') ||
          name.contains('coffee') ||
          name.contains('cafe')) {
        return {
          'icon': '‚òï',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF8D6E63
        };
      } else {
        // Default expense emoji
        return {
          'icon': 'üí∏',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFF6B35
        };
      }
    } else {
      // Income categories with specific emojis
      if (name.contains('l∆∞∆°ng') ||
          name.contains('salary') ||
          name.contains('work')) {
        return {
          'icon': 'üíº',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF4CAF50
        };
      } else if (name.contains('th∆∞·ªüng') ||
          name.contains('bonus') ||
          name.contains('gift')) {
        return {
          'icon': 'üéÅ',
          'iconType': CategoryIconType.emoji,
          'color': 0xFFFFD700
        };
      } else if (name.contains('ƒë·∫ßu t∆∞') ||
          name.contains('investment') ||
          name.contains('stock')) {
        return {
          'icon': 'üìà',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF00BCD4
        };
      } else if (name.contains('b√°n') ||
          name.contains('sell') ||
          name.contains('sale')) {
        return {
          'icon': 'üí∏',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF9C27B0
        };
      } else if (name.contains('ti·∫øt ki·ªám') ||
          name.contains('saving') ||
          name.contains('bank')) {
        return {
          'icon': 'üè¶',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF2196F3
        };
      } else if (name.contains('freelance') || name.contains('t·ª± do')) {
        return {
          'icon': 'üíª',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF673AB7
        };
      } else if (name.contains('cho thu√™') ||
          name.contains('rent') ||
          name.contains('rental')) {
        return {
          'icon': 'üè¢',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF795548
        };
      } else {
        // Default income emoji
        return {
          'icon': 'üí∞',
          'iconType': CategoryIconType.emoji,
          'color': 0xFF4CAF50
        };
      }
    }
  }

  /// Map scan result th√†nh TransactionModel
  Future<TransactionModel> mapScanResultToTransaction(
      Map<String, dynamic> scanResult, String userId) async {
    try {
      // Parse transaction type
      final transactionType = scanResult['type'] == 'income'
          ? TransactionType.income
          : TransactionType.expense;

      // Parse amount
      final amount = (scanResult['amount'] ?? 0).toDouble();

      // Parse date
      DateTime transactionDate;
      try {
        transactionDate = DateTime.parse(scanResult['date'] ?? '');
      } catch (e) {
        transactionDate = DateTime.now();
      }

      // T√¨m category ID
      String categoryId = 'other';
      String categoryName = scanResult['category_name'] ??
          scanResult['category_suggestion'] ??
          '';

      if (categoryName.isNotEmpty) {
        final categoryService = _getIt<CategoryService>();
        final categoriesStream =
            categoryService.getCategories(type: transactionType);
        final categories = await categoriesStream.first;
        final filteredCategories =
            categories.where((cat) => !cat.isDeleted).toList();

        // T√¨m category ch√≠nh x√°c
        for (final category in filteredCategories) {
          if (category.name.toLowerCase() == categoryName.toLowerCase()) {
            categoryId = category.categoryId;
            categoryName = category.name;
            break;
          }
        }

        // N·∫øu kh√¥ng t√¨m th·∫•y, t√¨m partial match
        if (categoryId == 'other') {
          for (final category in filteredCategories) {
            if (category.name
                    .toLowerCase()
                    .contains(categoryName.toLowerCase()) ||
                categoryName
                    .toLowerCase()
                    .contains(category.name.toLowerCase())) {
              categoryId = category.categoryId;
              categoryName = category.name;
              break;
            }
          }
        }

        // S·ª≠ d·ª•ng category ƒë·∫ßu ti√™n n·∫øu v·∫´n kh√¥ng t√¨m th·∫•y
        if (categoryId == 'other' && filteredCategories.isNotEmpty) {
          categoryId = filteredCategories.first.categoryId;
          categoryName = filteredCategories.first.name;
        }
      }

      // T·∫°o note t·ª´ description
      String note = scanResult['note'] ??
          scanResult['description'] ??
          'Giao d·ªãch t·ª´ scan AI';

      return TransactionModel(
        transactionId: '',
        userId: userId,
        categoryId: categoryId,
        categoryName: categoryName,
        amount: amount,
        type: transactionType,
        date: transactionDate,
        note: note,
        createdAt: DateTime.now(),
        updatedAt: DateTime.now(),
        isDeleted: false,
      );
    } catch (e) {
      _logger.e('Error mapping scan result to transaction: $e');
      rethrow;
    }
  }

  /// Validate scan result tr∆∞·ªõc khi l∆∞u
  Map<String, dynamic> validateScanResult(Map<String, dynamic> scanResult) {
    final errors = <String>[];

    // Ki·ªÉm tra amount
    final amount = scanResult['amount'];
    if (amount == null || amount <= 0) {
      errors.add('S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá');
    }

    // Ki·ªÉm tra type
    final type = scanResult['type'];
    if (type != 'income' && type != 'expense') {
      errors.add('Lo·∫°i giao d·ªãch kh√¥ng h·ª£p l·ªá');
    }

    // Ki·ªÉm tra date
    try {
      if (scanResult['date'] != null) {
        DateTime.parse(scanResult['date']);
      }
    } catch (e) {
      errors.add('Ng√†y giao d·ªãch kh√¥ng h·ª£p l·ªá');
    }

    return {
      'isValid': errors.isEmpty,
      'errors': errors,
    };
  }
}
